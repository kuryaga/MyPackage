quant_idf <- reshape2::melt(data = quant_all,
id.vars = "dur",
variable.name = "rp")
idf_dta[[i]] <- quant_idf
}, error = function(e) {
warning(paste("Error processing data table", i, ": ", conditionMessage(e)))
})
}
idf_results <- data.table::rbindlist(l = idf_dta,
idcol = "location_id")
idf_plot <- ggplot2::ggplot(data = idf_results,
mapping = ggplot2::aes(x = as.numeric(x = dur),
y = value,
colour = rp)) +
ggplot2::geom_line() +
ggplot2::geom_point() +
ggplot2::scale_colour_manual(name = "Return\nperiod",
values = c("red1", "magenta", "yellow3",
"green", "blue", "purple")) +
ggplot2::labs(x = "Duration (hours)",
y = "Intensity (mm/h)",
title = "IDF curve") +
ggplot2::theme_bw() +
ggplot2::facet_wrap(facets = ~location_id)
return(list(data = idf_results, plot = idf_plot))
}
calculate_idf(sample_data)
#'
#' @return a list containing two elements:
#'   - 'data': a data table
#'   - 'plot': a ggplot object visualizing the IDF curve
#'
#' @examples
#' idf_result <- calculate_idf(data_list = my_data, return_periods = c(2, 5, 10, 25, 50, 100), durations = c(1, 2, 5, 10, 24, 48))
#' print(idf_result$data)
#' print(idf_result$plot)
#' @export
calculate_idf <- function(data_list,
return_periods = c(2, 5, 10, 25, 50, 100),
durations = c(1, 2, 5, 10, 24, 48),
distribution = "gev", ...) {
idf_dta <- list()
for (i in seq_along(data_list)) {
tryCatch({
x <- data_list[[i]]
agg <- lapply(
X = durations,
FUN = function(d) {
out <- x[, .(time = as.POSIXct(time, origin = "1970-01-01"),
val = data.table::rollmean(value, n = d, align = "center", fill = 0))]
out
}
)
quant <- lapply(
X = agg,
FUN = function(a) {
mx <- a[, .(mx = max(x = val,
na.rm = TRUE)),
by = lubridate::year(x = time)]
para <- CoSMoS::fitDist(data = mx$mx,
dist = distribution,
n.points = 10,
norm = "N4",
constrain = FALSE)
prob <- 1 - 1/return_periods
q <- stats::qgev(p = prob,
loc = para$loc,
scale = para$scale,
shape = para$shape)
names(x = q) <- return_periods
as.list(x = q)
}
)
names(x = quant) <- durations
quant_all <- data.table::rbindlist(l = quant,
idcol = "dur")
quant_idf <- reshape2::melt(data = quant_all,
id.vars = "dur",
variable.name = "rp")
idf_dta[[i]] <- quant_idf
}, error = function(e) {
warning(paste("Error processing data table", i, ": ", conditionMessage(e)))
})
}
idf_results <- data.table::rbindlist(l = idf_dta,
idcol = "location_id")
idf_plot <- ggplot2::ggplot(data = idf_results,
mapping = ggplot2::aes(x = as.numeric(x = dur),
y = value,
colour = rp)) +
ggplot2::geom_line() +
ggplot2::geom_point() +
ggplot2::scale_colour_manual(name = "Return\nperiod",
values = c("red1", "magenta", "yellow3",
"green", "blue", "purple")) +
ggplot2::labs(x = "Duration (hours)",
y = "Intensity (mm/h)",
title = "IDF curve") +
ggplot2::theme_bw() +
ggplot2::facet_wrap(facets = ~location_id)
return(list(data = idf_results, plot = idf_plot))
}
calculate_idf(sample_data)
#'
#' @return a list containing two elements:
#'   - 'data': a data table
#'   - 'plot': a ggplot object visualizing the IDF curve
#'
#' @examples
#' idf_result <- calculate_idf(data_list = my_data, return_periods = c(2, 5, 10, 25, 50, 100), durations = c(1, 2, 5, 10, 24, 48))
#' print(idf_result$data)
#' print(idf_result$plot)
#' @export
calculate_idf <- function(data_list,
return_periods = c(2, 5, 10, 25, 50, 100),
durations = c(1, 2, 5, 10, 24, 48),
distribution = "gev", ...) {
idf_dta <- list()
for (i in seq_along(data_list)) {
tryCatch({
x <- data_list[[i]]
agg <- lapply(
X = durations,
FUN = function(d) {
out <- x[, .(time = as.POSIXct(time, origin = "1970-01-01"),
val = data.table::frollmean(value, n = d, align = "center", fill = 0))]
out
}
)
quant <- lapply(
X = agg,
FUN = function(a) {
mx <- a[, .(mx = max(x = val,
na.rm = TRUE)),
by = lubridate::year(x = time)]
para <- CoSMoS::fitDist(data = mx$mx,
dist = distribution,
n.points = 10,
norm = "N4",
constrain = FALSE)
prob <- 1 - 1/return_periods
q <- stats::qgev(p = prob,
loc = para$loc,
scale = para$scale,
shape = para$shape)
names(x = q) <- return_periods
as.list(x = q)
}
)
names(x = quant) <- durations
quant_all <- data.table::rbindlist(l = quant,
idcol = "dur")
quant_idf <- reshape2::melt(data = quant_all,
id.vars = "dur",
variable.name = "rp")
idf_dta[[i]] <- quant_idf
}, error = function(e) {
warning(paste("Error processing data table", i, ": ", conditionMessage(e)))
})
}
idf_results <- data.table::rbindlist(l = idf_dta,
idcol = "location_id")
idf_plot <- ggplot2::ggplot(data = idf_results,
mapping = ggplot2::aes(x = as.numeric(x = dur),
y = value,
colour = rp)) +
ggplot2::geom_line() +
ggplot2::geom_point() +
ggplot2::scale_colour_manual(name = "Return\nperiod",
values = c("red1", "magenta", "yellow3",
"green", "blue", "purple")) +
ggplot2::labs(x = "Duration (hours)",
y = "Intensity (mm/h)",
title = "IDF curve") +
ggplot2::theme_bw() +
ggplot2::facet_wrap(facets = ~location_id)
return(list(data = idf_results, plot = idf_plot))
}
calculate_idf(sample_data)
#'
#' @return a list containing two elements:
#'   - 'data': a data table
#'   - 'plot': a ggplot object visualizing the IDF curve
#'
#' @examples
#' idf_result <- calculate_idf(data_list = my_data, return_periods = c(2, 5, 10, 25, 50, 100), durations = c(1, 2, 5, 10, 24, 48))
#' print(idf_result$data)
#' print(idf_result$plot)
#' @export
calculate_idf <- function(data_list,
return_periods = c(2, 5, 10, 25, 50, 100),
durations = c(1, 2, 5, 10, 24, 48),
aggregation_function = "mean",
distribution = "gev", ...) {
idf_dta <- list()
for (i in seq_along(data_list)) {
tryCatch({
x <- data_list[[i]]
agg <- lapply(
X = durations,
FUN = function(d) {
out <- x[, .(time = as.POSIXct(time, origin = "1970-01-01"),
val = do.call(what = paste0("froll", aggregation_function),
args = list(x = value,
n = d,
align = "center",
fill = 0)))]
out
}
)
quant <- lapply(
X = agg,
FUN = function(a) {
mx <- a[, .(mx = max(x = val,
na.rm = TRUE)),
by = year(x = time)]
para <- CoSMoS::fitDist(data = mx$mx,
dist = distribution,
n.points = 10,
norm = "N4",
constrain = FALSE)
prob <- 1 - 1/return_periods
q <- qgev(p = prob,
loc = para$loc,
scale = para$scale,
shape = para$shape)
names(x = q) <- return_periods
as.list(x = q)
}
)
names(x = quant) <- durations
quant_all <- rbindlist(l = quant,
idcol = "dur")
quant_idf <- melt(data = quant_all,
id.vars = "dur",
variable.name = "rp")
idf_dta[[i]] <- quant_idf
}, error = function(e) {
warning(paste("Error processing data table", i, ": ", conditionMessage(e)))
})
}
idf_results <- data.table::rbindlist(l = idf_dta,
idcol = "location_id")
idf_plot <- ggplot2::ggplot(data = idf_results,
mapping = aes(x = as.numeric(x = dur),
y = value,
colour = rp)) +
geom_line() +
geom_point() +
scale_colour_manual(name = "Return\nperiod",
values = c("red1", "magenta", "yellow3",
"green", "blue", "purple")) +
labs(x = "Duration (hours)",
y = "Intensity (mm/h)",
title = "IDF curve") +
theme_bw() +
facet_wrap(facets = ~location_id)
return(list(data = idf_results, plot = idf_plot))
}
library(CoSMoS)
libray(data.table)
library(data.table)
#'
#' @return a list containing two elements:
#'   - 'data': a data table
#'   - 'plot': a ggplot object visualizing the IDF curve
#'
#' @examples
#' idf_result <- calculate_idf(data_list = my_data, return_periods = c(2, 5, 10, 25, 50, 100), durations = c(1, 2, 5, 10, 24, 48))
#' print(idf_result$data)
#' print(idf_result$plot)
#' @export
calculate_idf <- function(data_list,
return_periods = c(2, 5, 10, 25, 50, 100),
durations = c(1, 2, 5, 10, 24, 48),
aggregation_function = "mean",
distribution = "gev", ...) {
idf_dta <- list()
for (i in seq_along(data_list)) {
tryCatch({
x <- data_list[[i]]
agg <- lapply(
X = durations,
FUN = function(d) {
out <- x[, .(time = as.POSIXct(time, origin = "1970-01-01"),
val = do.call(what = paste0("froll", aggregation_function),
args = list(x = value,
n = d,
align = "center",
fill = 0)))]
out
}
)
quant <- lapply(
X = agg,
FUN = function(a) {
mx <- a[, .(mx = max(x = val,
na.rm = TRUE)),
by = year(x = time)]
para <- CoSMoS::fitDist(data = mx$mx,
dist = distribution,
n.points = 10,
norm = "N4",
constrain = FALSE)
prob <- 1 - 1/return_periods
q <- qgev(p = prob,
loc = para$loc,
scale = para$scale,
shape = para$shape)
names(x = q) <- return_periods
as.list(x = q)
}
)
names(x = quant) <- durations
quant_all <- rbindlist(l = quant,
idcol = "dur")
quant_idf <- melt(data = quant_all,
id.vars = "dur",
variable.name = "rp")
idf_dta[[i]] <- quant_idf
}, error = function(e) {
warning(paste("Error processing data table", i, ": ", conditionMessage(e)))
})
}
idf_results <- data.table::rbindlist(l = idf_dta,
idcol = "location_id")
idf_plot <- ggplot2::ggplot(data = idf_results,
mapping = aes(x = as.numeric(x = dur),
y = value,
colour = rp)) +
geom_line() +
geom_point() +
scale_colour_manual(name = "Return\nperiod",
values = c("red1", "magenta", "yellow3",
"green", "blue", "purple")) +
labs(x = "Duration (hours)",
y = "Intensity (mm/h)",
title = "IDF curve") +
theme_bw() +
facet_wrap(facets = ~location_id)
return(list(data = idf_results, plot = idf_plot))
}
calculate_idf(sample_data)
library(testthat)
test_that("calculate_idf function calculates IDF quantiles and generates plot", {
expect_that(calculate_idf(x_list = sample_data)$idf_results, is_a("data.table"))
expect_that(calculate_idf(x_list = sample_data)$idf_plot, is_a("ggplot"))
expect_equal(colnames(calculate_idf(x_list = sample_data)$idf_results), c("location_id", "dur", "rp", "value"))
expect_false(is.null(calculate_idf(x_list = sample_data)$idf_plot))
})
test_that("calculate_idf function calculates IDF quantiles and generates plot", {
expect_that(calculate_idf(data_list = sample_data)$idf_results, is_a("data.table"))
expect_that(calculate_idf(data_list = sample_data)$idf_plot, is_a("ggplot"))
expect_equal(colnames(calculate_idf(data_list = sample_data)$idf_results), c("location_id", "dur", "rp", "value"))
expect_false(is.null(calculate_idf(data_list = sample_data)$idf_plot))
})
result <- calculate_idf(sample_data)
View(result)
View(result)
test_that("calculate_idf function calculates IDF quantiles and generates plot", {
expect_that(calculate_idf(data_list = sample_data)$data, is_a("data.table"))
expect_that(calculate_idf(data_list = sample_data)$plot, is_a("ggplot"))
expect_equal(colnames(calculate_idf(data_list = sample_data)$idf_results), c("location_id", "dur", "rp", "value"))
expect_false(is.null(calculate_idf(data_list = sample_data)$idf_plot))
})
test_that("calculate_idf function calculates IDF quantiles and generates plot", {
expect_that(calculate_idf(data_list = sample_data)$data, is_a("data.table"))
expect_that(calculate_idf(data_list = sample_data)$plot, is_a("ggplot"))
})
devtools::document()
devtools::document()
#' @param data_directory path to the directory containing the files
#' @param file_pattern file pattern to match NetCDF files
#' @param location_ids vector of location IDs to extract values
#'
#' @return a list of data tables split by location_id
#'
#' @examples
#' extract_values_from_nc(data_directory = "./data", file_pattern = ".nc", location_ids = c(327, 328, 329))
#'
#' @export
extract_values_from_nc <- function(data_directory = "./data",
file_pattern = ".nc",
location_ids)  {
if (!dir.exists(data_directory)) {
message("Specified directory does not exist")
return(NULL)
}
files <- base::list.files(path = data_directory,
recursive = TRUE,
pattern = file_pattern,
full.names = TRUE)
data_all <- base::lapply(
X = files,
FUN = function(file) {
e <- base::try({
nc <- ncdf4::nc_open(filename = file)
lon <- ncdf4::ncvar_get(nc = nc, varid = "lon")
lat <- ncdf4::ncvar_get(nc = nc, varid = "lat")
pr <- ncdf4::ncvar_get(nc = nc, varid = "pr")
time <- base::as.POSIXct(ncdf4.helpers::nc.get.time.series(f = nc), format = "%Y-%m-%d %H:%M:%S")
ncdf4::nc_close(nc = nc)
r <- terra::rast(x = pr)
terra::ext(x = r) <- c(base::range(lon), base::range(lat))
terra::crs(x = r) <- "epsg:4326"
xy <- terra::xyFromCell(object = r, cell = location_ids)
val <- base::t(x = terra::extract(x = r, y = xy))
data <- data.table::data.table(time = time, value = val)
}, silent = TRUE)
if (base::inherits(x = e, what = "try-error")) {
return(NULL)
} else {
return(data)
}
}
)
data_all <- data.table::rbindlist(l = data_all)
data_all_m <- data.table::melt(data = data_all,
id.vars = "time",
variable.name = "location_id")
max_values <- data_all_m[, .(max_value = base::max(value)),
by = .(location_id, lubridate::year(x = time))]
split_data <- base::split(x = data_all_m,
f = data_all_m$location_id)
return(split_data)
}
#'
#' @return a list containing two elements:
#'   - 'data': a data table
#'   - 'plot': a ggplot object visualizing the IDF curve
#'
#' @examples
#' idf_result <- calculate_idf(data_list = my_data, return_periods = c(2, 5, 10, 25, 50, 100), durations = c(1, 2, 5, 10, 24, 48))
#' print(idf_result$data)
#' print(idf_result$plot)
#' @export
calculate_idf <- function(data_list,
return_periods = c(2, 5, 10, 25, 50, 100),
durations = c(1, 2, 5, 10, 24, 48),
aggregation_function = "mean",
distribution = "gev", ...) {
idf_dta <- list()
for (i in seq_along(data_list)) {
tryCatch({
x <- data_list[[i]]
agg <- lapply(
X = durations,
FUN = function(d) {
out <- x[, .(time = as.POSIXct(time, origin = "1970-01-01"),
val = do.call(what = paste0("froll", aggregation_function),
args = list(x = value,
n = d,
align = "center",
fill = 0)))]
out
}
)
quant <- lapply(
X = agg,
FUN = function(a) {
mx <- a[, .(mx = max(x = val,
na.rm = TRUE)),
by = year(x = time)]
para <- CoSMoS::fitDist(data = mx$mx,
dist = distribution,
n.points = 10,
norm = "N4",
constrain = FALSE)
prob <- 1 - 1/return_periods
q <- qgev(p = prob,
loc = para$loc,
scale = para$scale,
shape = para$shape)
names(x = q) <- return_periods
as.list(x = q)
}
)
names(x = quant) <- durations
quant_all <- rbindlist(l = quant,
idcol = "dur")
quant_idf <- melt(data = quant_all,
id.vars = "dur",
variable.name = "rp")
idf_dta[[i]] <- quant_idf
}, error = function(e) {
warning(paste("Error processing data table", i, ": ", conditionMessage(e)))
})
}
idf_results <- data.table::rbindlist(l = idf_dta,
idcol = "location_id")
idf_plot <- ggplot2::ggplot(data = idf_results,
mapping = aes(x = as.numeric(x = dur),
y = value,
colour = rp)) +
geom_line() +
geom_point() +
scale_colour_manual(name = "Return\nperiod",
values = c("red1", "magenta", "yellow3",
"green", "blue", "purple")) +
labs(x = "Duration (hours)",
y = "Intensity (mm/h)",
title = "IDF curve") +
theme_bw() +
facet_wrap(facets = ~location_id)
return(list(data = idf_results, plot = idf_plot))
}
devtools::document()
rlang::last_trace()
devtools::document()
library(MyPackage)
library(devtools)
devtools::install()
